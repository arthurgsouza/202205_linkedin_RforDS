---
title: "Arrumação e Transformação de Dados"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

# Bibliotecas

```{r}
library(tidyverse)
```


dplyrassisstent

    
# Manuseando Colunas 

A próxima etapa no processo de análise é a manipulação da base visando desde o entendimento de suas variáveis, considerando tabulações e estatísticas, até a criação de novas variáveis. Para tal, trabalharemos com o pacote `dplyr`, com recursos para:

Limpeza, data cleaning 


## selecionando colunas 

Por nome ou por posição

Ou ainda linhas, observações, que não se refiram ao nosso objetivo de estudo


    - `select()` - seleciona variáveis, permitindo o uso de recursos como:
        - `starts_with()`, `matches()`, `num_range()`, ou `everything()`  
        
        
## selecionando linhas

por posição pelo valor 

* filter for particular observations, arrange the observations in a desired order, and mutate to add or change a column.

    - `filter()` - filtra linhas da base de dados a partir de critérios lógicos (retorno `TRUE`/`FALSE`)
    - `slice()` - seleciona linhas por suas posições ordinais
    - `top_n()` - ordena as primeiras `n` observações das colunas listadas 
    - `arrange()` - ordena as linhas de acordo com as colunas especificadas
    - `distinct()` - remove as linhas duplicadas de uma dada entrada

```{r}
#exemplo: seleção segundo padrão de nomenclatura + filtro e ordenação
  iris %>% 
    select(starts_with("Petal")) %>%
    filter(Petal.Length > 6, Petal.Width > 2) %>% 
    arrange(Petal.Width)

#exemplo: valor máximo de Sepal.Length para cada specie
  iris %>% 
    group_by(Species) %>% 
    top_n(1, Sepal.Length)
  
```

por amostra

    - `sample_n()` - seleciona uma amostra aleatória considerando o número de elementos especificado
    - `sample_frac()` - seleciona uma amostra aleatória considerando a proporção especificada
 
```{r}
#exemplo: amostra considerando o número de observações desejado 
# seguido de uma amostra considerando proporção
  iris %>% 
    sample_n(10) %>% 
    sample_frac(0.5) 
```



        
## alterando e criando novas colunas

excluindo

    - `mutate()` - cria/modifica variáveis
    - `rename()` - renomeia variáveis
`arrange()` - renomeia variáveis

convertendo dados!

```{r}
#base exemplo
  iris[1:5,] %>% as_tibble()

#exemplo: seleção, mudança de nome, e definição de uma nova variável 
  iris[1:5,] %>% 
    as_tibble() %>% 
    select(Sepal.Length) %>% 
    rename(variavel_original = Sepal.Length) %>% 
    mutate(variavel_original_normalizada =  variavel_original %>% scale)
```

•	ifelse, case_when

## criando sumarizações

    - `summarise()` - calcula resumos de uma tabela conforme especificação

o	Media
o	Quantil 


```{r}
#exemplo: calculo da quantidade de observações de cada categoria, e 
# média para a variável Petal.Length considerando a visão por Species
  iris %>% 
    group_by(Species) %>% 
    summarise(N = n(),
              PetalLength_media = mean(Petal.Length))
```   

## criando sumarizações por grupo

    - `group_by()` - manipula a base de dados segmentando por cada "grupo" da variável especificada e, posteriormente, combina os resultados, considerando os comandos seguintes dados.



# Redimensionando os dados (dados tidy)

função que ajuda : https://r-rudra.github.io/tidycells/

   # A filosofia tidy, é uma forma de vincular a estrutura de um  
  # conjunto de dados (seu layout físico) com sua semântica (seu significado).  
  # Para tal, temos que, independente da origem, características, problemas e 
  # layout dos dados, estes precisam ser organizados garantindo que:
    
    # cada variável/informação tenha a sua própria coluna;
    # cada observação/unidade de análise tenha a sua própria linha; e
    # que cada valor tenha a sua própria célula.
    
  # Apesar da simplicidade das premissas, respeitá-las permite um grande ganho 
  # em termos de produtividade de análise. Contudo, nem sempre é trivial obter  
  # esta estrutura. Ponto este, que o próprio ecossistema de pacotes do tidyverse   
  # nos auxilia, oferecendo uma série de recursos para a obtenção e manutenção 
  # de uma estrutura tidy. 


  
Vamos agora retornar em um conceito importante para 
Após a importação dos dados, passamos para a etapa de tidy dos dados, também chamada de *tidying data*. Para isto iremos primeiramente visualizar os dados. No R, existem várias funções *built-in* para isto, como a função `names()`, que retorna o nome das colunas, ou `str()`, que permite a visualização da estrutura de um objeto arbitrário.   

Todas as funções citadas serão igualmente úteis e utilizadas no contexto do `tidyverse`, mas, com o pacote `dplyr`, passamos a ter também a opção `glimpse()`. Nesta, de modo similar ao `str()`, temos o número de observações (linhas) e variáveis (colunas) dos dados, porém com a quantidade de observações ajustadas ao display do Console.

```{r}
#exemplo: função `glimpse` para visualização 
  mtcars %>% glimpse()
```

A partir da visualização, começamos a fazer os ajustes necessários para garantir que os dados estejam organizados de uma forma `tidy`, tendo como principal ferramenta a biblioteca `tidyr`. Seguem as principais funções deste pacote, utilizando bases disponíveis pela própria biblioteca:


## pivotando 

Uma outra ação comum, diz respeito a necessidade de combinar diferentes bases de dados visando obter uma fonte única, com todas as informações de interesse, aqui denominada agregação.

### de colunas para linhas 

  - `gather()` - reorganiza os dados, combinando as colunas especificadas na coluna parâmetro `key`, e seus valores na coluna parâmetro `value`. Com tal tipo de ajuste podemos organizar os dados de modo a consultar várias colunas de interesse de uma única vez, algo útil para a aplicação de loops, funções e gráficos, conforme veremos na seção `Visualização`.

```{r}
#base para exemplo
  table4a

#exemplo: passando as colunas para linhas
  table4a_new <- table4a %>% 
    gather(`1999`, `2000`, key = "ano", value = "valores") 
  
  table4a_new
```


### de linhas para colunas

- `spread()` - de maneira oposta a função anterior, aqui podemos expandir linhas em colunas:

```{r}
#exemplo: passando linhas para colunas
  table4a_new %>% 
    spread(ano, valores) 
```


## combinando colunas  


  - `separate()` - divide uma única coluna em várias colunas, similarmente a opção `separate_rows()`, que faz a mesma coisa para linhas.
```{r}
#base para exemplo
  table3

#exemplo: dividindo colunas
  table3 %>% separate(rate, into = c("cases","pop"))
  
#exemplo: dividindo linhas
  table3 %>% separate_rows(rate)
```
  
  - `unite()` - e de maneira oposta as separações, temos a função que combina várias colunas.

```{r}
#base para exemplo
  table3_separate <- table3 %>% separate(rate, into = c("cases", "pop"))

#exemplo: separando a coluna rate em duas
  table3_separate %>%
    unite(cases, pop, col = "rate", sep = "/")
```








# Combinando Bases

    - `inner_join()` - retorna todas as linhas da base à esquerda que possuem valores correspondentes na base à direita. Se houver várias correspondências entre x e y, todas as combinações das correspondências serão retornadas.
    - `left_join()` - retorna todas as linhas de x e todas as colunas de x e y. Linhas em x sem correspondência em y terão valores de NA nas novas colunas. Se houver várias correspondências entre x e y, todas as combinações das correspondências serão retornadas.
    - `full_join()` - retorna todas as linhas e todas as colunas de xe y. Onde não há valores correspondentes, retorna NA para o ausente.
    
```{r, collapse = T}
#bases para exemplo
  band_members %>% glimpse()
  band_instruments %>% glimpse()
  band_instruments2 %>% glimpse()

#exemplo: em que as variáveis para join possuem nomes iguais
  left_join(band_members, band_instruments) %>% glimpse()

#exemplo: em que as variáveis para join possuem nomes diferentes
  left_join(band_members, band_instruments2, by = c("name"="artist")) %>%
    glimpse()
```



# Recursos avançados

O dplyr é o pacote mais útil para realizar transformação de dados, aliando simplicidade e eficiência de uma forma elegante. Os scripts em R que fazem uso inteligente dos verbos dplyr e as facilidades do operador pipe tendem a ficar mais legíveis e organizados sem perder velocidade de execução.

As principais funções do dplyr são:

select() - seleciona colunas mutate() - cria/modifica colunas rename() - renomeia variáveis group_by() - agrupa a base summarise() - sumariza a base filter() - filtra linhas arrange() - ordena a base

Com a nova versão 1.0 do pacote dplyr, surgiu uma nova função across(), que nos ajuda a aplicar cálculos de forma simultânea a multiplas colunas.


```{r}
starwars %>% 
    summarise(across(is.numeric, mean, na.rm = T))


starwars %>% 
    summarise(across(contains("_color"), n_distinct))
```




Até aqui o tidyverse apresenta o seu ponto forte em termos de legibilidade do código, aproximação com a maneira com que pensamos as ações que gostariamos de aplicar nos dados. Mas são nos recursos avançados que vemos ganhos consideráveis em termos de produtividade. 

* across, relocate
	        #adicionar exemplos de formas de definir funções
        # avengers %>% summarise(across(contains("Death"), ~ sum(is.na(.x)))) %>% glimpse
        # avengers %>% summarise(across(contains("Death"), function(x) sum(is.na(x)))) %>% glimpse



# HANDS-ON


