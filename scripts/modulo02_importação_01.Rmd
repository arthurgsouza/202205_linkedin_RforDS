---
title: "Importação de Dados"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Utilizando dados tabulares pré existentes no R

No R temos acesso a diversas bases de dados, para consultá-las podemos utilizar a função `data()`. E para cada biblioteca carregada, teremos uma atualização na lista de dados:

```{r}
library(tidyverse)
data()
```

Estas bases de dados são diretamente acessíveis, por exemplo `r AirPassengers`. Mas para que os dados constem na janela de Environment, precisamos carregá-las de outra maneira, como `data("AirPassengers") ` ou :

```{r}
AirPassengers <- AirPassengers
```

## pacotes com bases interessantes

```{r}
#base de dados 
  #dados::

#bla bla bla
  #pacman::

#bla bla bla
  #charlatan::

#API do IBGE
  #sidrar::
```

Como última dica, gostaria de deixar o #siteShiny: 



# Lendo dados

A etapa de importação de dados pode significar ler dados armazenados em arquivos de diferentes extensões, dados provenientes de outras ferramentas, APIs da Web, e etc.

## Via point-and-click
Para a leitura de arquivos tabulares, vamos primeiro considerar a opção Point-and-Click:
`File > Import Dataset > From ... `, onde você poderá definir as especificações de leitura, tendo os respectivos comandos.

Uma alternativa também é por meio do comando `file.choose()`, que abre um pop-up para que você possa selecionar o seu arquivo:


```{r}
#file.choose()
```

## Via código
Considerando agora algumas opções do pacote `readr` do tidyverse. Seguem alguns exemplos para a leitura de um arquivo "file", que esteja presente no seu diretório corrente de trabalho, considerando diferentes opções de extensões e delimitadores:

* read_csv("file.csv") - lê arquivos delimitados por vírgula
* read_csv2("file.csv") - lê arquivos delimitados por ponto e vírgula
* read_delim("file.txt", delim="|") - lê arquivos delimitados por tabulação (exemplo dado para o delimitador |)
* read_fwf("file.fwf", col_positions = c(1,3,5)) - lê arquivos com largura fixa (exemplo dado para o padrão 1,3,5)

Em todos os casos é possível especificar características como: nome das colunas, cabeçalho, linhas para serem puladas, ou ainda a pré-especificação da classe de cada uma das colunas do arquivo. Contudo, no caso deste último parâmetro não ser listado, as funções do `readr` irão “adivinhar” a classe das colunas, retornando uma mensagem com tais informações.


conforme exemplo abaixo:

```{r}
#read_csv(readr_example("mtcars.csv"))
readr_example("mtcars.csv")
```

Adicionalmente temos opções de outros pacotes, que possibilitam mais recursos de leituras, algumas destas opções serão listadas ao fim deste documento.

# Visualizações iniciais


```{r}
pixar_filmes <- dados::pixar_filmes
pixar_filmes
```

Podemos ver os dados por meio de funções como `View(pixar_filmes)`, `r `head(pixar_filmes)` ou `r str(pixar_filmes)`, mas um dos recursos que utilizaremos com mais frequência será a função `glimpse()`, onde podemos ver cada coluna da base de dados, seu tipo, e vemos as primeiras observações.  

```{r}
pixar_filmes %>% glimpse()
```

Aqui temos um primeiro contato com um dos conceitos mais importantes para iniciar uma análise de dados: o entendimento dos tipos de dados. Aqui temos informações do tipo: character, ou seja palavras, double, isto é números, e data, que trata-se de um tipo de dados com caracteristicas próprias. Como uma prévia da importancia deste conceito, note que com a função `summary()` temos calculos diferentes a depender do tipo da variável, mas voltaremos neste ponto mais a frente. 

```{r}
pixar_filmes %>% summary()
```

# Salvando e lendo arquivos

Vamos inicialmente escrever um arquivo, e então vamos ler novamente.

Com a função `write.table()`, tendo como parametros o nome do objeto a ser exportado e o path, ou seja, o caminho onde você espera que o arquivo criado seja salvo. 

```{r}
state <- mtcars

#exporte os dados em um arquivo .csv
write.csv(state, "base_exportada.csv")
```


Para saber qual o diretório de trabalho corrente, utilizamos o comando `getwd()` (*get working directory*) 

```{r}
getwd()
```

Enquanto que para alterar o diretório de trabalho temos a função `setwd()` (*set working directory*).


```{r}
#qual a função que altera o diretório
  #C:\\Users\\natyd\\Desktop
  setwd("C:/Users/natyd/Desktop")
```

Para a leitura de arquivos: `read.table`. Vamos ler o objeto que foi salvo, em um novo objeto.

```{r}
state1 <- read.csv("base_exportada.csv")
state1
```

Alternativamente podemos especificar o destino do arquivo de interesse, precedendo o nome do arquivo com o diretório desejado, p.e.: `write.table(mtcars, file = "C:/Users/mtcars.txt")` note que trabalhamos com barras simples (`/` ou `\\`) para especificação de diretórios.

Tanto a função `write.table()` quanto a `read.table()`possuem uma série de parâmetros, permitindo especificações de separadores, títulos e comentários, além de variações de extenção para consultar funções relacionadas pesquise os tópicos `??read` e `??write`.


# Trabalhando com Projetos

Existe ainda a alternativa de trabalhar com projetos (`.RProj`). Nestes, o diretório em que o arquivo `.RProj` estiver salvo, passa a ser a pasta raiz da análise. Para criar um projeto no RStudio, é necessário clicar no ícone superior à direita. 

Uma dica: use o pacote usethis::create_project()


# Importando outros tipos de dados

 `readxl` e `haven`, anteriormente citadas, o R dispõe ainda de bibliotecas como: `DBI`, `jsonlite`, `xml2`, `httr` ou o `sparklyr`, esta última particularmente interessante no contexto de Big Data.
 
- feather: para compartilhar arquivos com Python e outras linguagens.
- haven: para trabalhar com arquivos do SPSS, SAS e Stata.
- httr: para web apps.
- jsonlite: para JSON arquivos.
- readxl: para arquivos .xls e .xlsx.
- rvest: para web scraping.
- xml2: para XML.



        #	Point-and-click - Rbase
        # precisa instalar várias bibliotecas
        # install.packages("Rcmdr")
        # library(Rcmdr)
